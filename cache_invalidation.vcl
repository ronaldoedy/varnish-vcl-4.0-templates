vcl 4.0;

acl purgers {
    # Define access control list to provide a list of IP's that allow us to perform maintenance tasks

# IPV4/IPV6 loopback
    "localhost";
    "127.0.0.1";
    "::1";

# IP RANGE CIDR
    "192.168.33.0"/24;

# We can exclude IP's, eg: gateways
    !"192.168.1.23";
}


sub vcl_recv {

    # req.restart increase when the return (restart) is called
    # so we are cleaning this header generated by the purge action when a normal request comes
    if(req.restarts == 0) {
        unset req.http.X-Purger;    
    }

    if(req.method == "PURGE") {
        if(!client.ip ~ purgers) {
            return (synth(405, "Method not allowed"));    
        }
        return (purge);
    }

    if(req.method == "BAN") {
        if(!client.ip ~ purgers) {
            return (synth(405, "Method not allowed"));
        } else {

            # PERFORM AN HTTP REQUEST SENDING [X-BAN-HOST AND X-BAN-URL] HEADERS TO ADD INSIDE BAN LIST
            # example using httpie : http -p hH BAN http://localhost 'x-ban-url: URL_PATTERN' 'x-ban-host: HOST_PATTERN'
            # example using varnish cli : varnishadm ban 'obj.http.x-url ~ URL_PATTERN && obj.http.x-host ~ HOST_PATTERN'

            ban("obj.http.x-host ~ " + req.http.x-ban-host + " && obj.http.x-url ~ " + req.http.x-ban-url);
            return (synth(200, "BAN ADDED"));
        }
    }
    # Refresh an specific cached object forcing the lookup operation to miss, take care of this method, a new version of the cached object is generated,
    # the old object will stay in the cache until ttl expires or it is evicted by some other means
    if(req.method == "REFRESH") {
        set req.method = "GET";
        set req.hash_always_miss = true;
    }
}

sub vcl_backend_response {

    # You can return a custom response header for debugging purposes
    set beresp.http.X-Varnish-Cookie-Debug = "Cleaned request cookies: " + bereq.http.Cookie;

    # Varnish only cache the following backend status codes :

        # 200: OK
        # 203: Non-Authoritative Information
        # 300: Multiple Choices
        # 301: Moved Permanently
        # 302: Moved Temporarily
        # 307: Temporary Redirect
        # 410: Gone
        # 404: Not Found

    # If you want to stop caching some previous status code :

    if(beresp.status == 404) {
    # Hit for pass for the next 2 minutes
        set beresp.ttl = 120s;
        set beresp.uncacheable = true;
    }

    # BANNING IMPORTANT POINTS

        # Bans are checked when we REQUEST a cached object , but before we deliver it OR when the ban lurker wakes up.
            # The first case is efficient only if you know that the cached objects to be banned are frequently accessed, otherwise you may accumulate a lot of ban expresions in the ban list that are never checked,
            # this accumulation occurs because BANS ARE KEPT UNTIL ALL cached objects (excluding those added to the cache after the ban creation timestamp have been checked against them.

        # There might be multiple bans in the same varnish instance.
        # A ban is applicable only for the contents that were present by the time it was created (Applied only on older cached objects than the time of the ban creation)
        # It will never prevent new objects being cached or delivered.
        # Too many ban lists per instance will consume too much cpu hence every request being served it might need to be matches across multiple ban list before deliver.
        # Long lived cache [assume infinite TTL] objects with no hits will remain untouched by bans and consumes memory.

    # BAN LURKER GOALS

        # Ban Lurker is a varnish process who will be actively walking the cache and invalidate objects against the ban list [by default off (enable it: varnishadm param.set ban_lurker_sleep [time])]
        # Ban lurker thread does not know anything about the request, that's why he can not perform cleaning operations against bans with request expresions
        # so set custom http headers to store with the related cache object for banning purposes :

    set beresp.http.x-url = bereq.url;
    set beresp.http.x-host = bereq.http.host;
}


sub vcl_purge {
    # Here the object has already been purged, the default behaviour is to send a synth subroutine call with status 200 Purged
    # but this time i prefer to send a GET Request with a restart to regenerate the content purged
    set req.method = "GET";
    set req.http.X-Purger = "PURGED";
    return (restart);
}

sub vcl_deliver {

    if(req.http.X-Purger){
        set resp.http.X-Purger = req.http.X-Purger;
        # Unset any useless response header when we are purging
        unset resp.http.x-cache;
        unset resp.http.X-Cache-Age;
        unset resp.http.X-Cache-Grace;
        unset resp.http.X-Cache-TTL-Remaining;
        unset resp.http.X-Hits;
        unset resp.http.X-Varnish-Cookie-Debug;
    }

    # Clean de custom banning headers added previously from vcl_backend_response, 
    # we don't need to see them in the response

    unset resp.http.x-url;
    unset resp.http.x-host;
    
}
